save_figure_or_not <- function(figure, filename, override = RESET_FIGURES) {
  require(processx)
  
  if (override || !file.exists(file.path('../../figures/plotly/', filename))) {
    orca(figure, file = file.path('../../figures/plotly/', filename))
  }
}

# Function for bivariate-gaussian-distribution-density
f.bivn <-function(x1, x2, mu, Sigma)
{
  rho<- Sigma[3]/(sqrt(Sigma[1])*sqrt(Sigma[4])) # setting the correlation coefficient between x1 and x2
  term1<-1/(2*pi*sqrt(Sigma[1]*Sigma[4]*(1-rho^2)))
  term2<--1/(2*(1-rho^2))
  term3<-(x1-mu[1])^2/Sigma[1]
  term4<-(x2-mu[2])^2/Sigma[4]
  term5<--2*rho*((x1-mu[1])*(x2-mu[2]))/(sqrt(Sigma[1])*sqrt(Sigma[4]))
  term1*exp(term2*(term3+term4-term5))
} # setting up the function of the multivariate normal density


fix_quadratic_effects <-function(data, n){
  data = as.matrix(data)
  
# Function to fix the quadratic effects along the cue dimension that is currently listed as a column in the data
  DT <- data.table(data)
  DT[, col_max := colnames(.SD)[max.col(.SD, ties.method = "first")]] # get column number that has the maximal value within each row
  DT$max <- apply(DT[,.SD, .SDcols = !c('col_max')], 1, max) # get the max value within each row
  
  d.DT <- as.data.frame(DT) %>%
    rownames_to_column('id') %>%
    pivot_longer(
      cols = starts_with("V"),
      names_to = "col_name",
      values_to = "prob") %>%
    mutate(
      need_to_fix = as.numeric(gsub("V", "", col_name)) < as.numeric(gsub("V", "",  col_max)), # criteria to fix the quadratic effect: for each row, if 1) the current value is smaller than the max value of the row and 2) the col_num of the current value is smaller (i.e., VOT is smaller) than the col_num of the max value, then replace the current value with the max value
      prob.fixed = ifelse(need_to_fix, max, prob)
    )
  
  resp.prob.fixed <- d.DT %>%
    select(id, col_name, prob.fixed) %>%
    pivot_wider(names_from = col_name, values_from = prob.fixed) %>%
    select(-id) %>%
    as.matrix()
  
  return(resp.prob.fixed)
}

# Function to demonstrate representations in 3D plots

demonstrate_representations_3D <- function(m, n, cue1_range, cue2_range, cue_names, lambda, pi, category_contrasts){
    output = vector(mode = "list", length = 2)
    for(i in 1:length(m$category)){
      mu = m$mu[[i]]
      Sigma = m$Sigma[[i]]
      category = m$category[i]
      
      
      x<-seq(cue1_range[1], cue1_range[2],length=n)  # generating the vector series cue 1
      y<-seq(cue2_range[1], cue2_range[2],length=n) # generating the vector series cue 2
      # print(mu)
      # print(Sigma)

       z<-t(outer(x,y,f.bivn, mu, Sigma)) # calculating the density values; transpose the matrix generated by 'outer': x is the first cue, y is the 2nd cue
      
      
      df = list(x,y,z)
      names(df) = c("x", "y", "z")


      if (category == m$category[1]){

        d.bivn = df
        rho = Sigma[3]/(sqrt(Sigma[1])*sqrt(Sigma[4]))
        # add ellipse at the bottom
        d.ellipse <- mixtools::ellipse(mu, matrix(c(Sigma[1], rho*sqrt(Sigma[1])*sqrt(Sigma[4]), rho*sqrt(Sigma[1])*sqrt(Sigma[4]), Sigma[4]), 2), alpha = .05, npoints = 250, newplot = F, draw = F)
        d.ellipse = cbind(as.data.frame(d.ellipse[,1]), as.data.frame(d.ellipse[,2]))
        colnames(d.ellipse) = cue_names
        d.prob = z
      }

      if (category == m$category[2]){

        t.bivn = df
        # add ellipse at the bottom
        t.ellipse <- mixtools::ellipse(mu, matrix(c(Sigma[1], rho*sqrt(Sigma[1])*sqrt(Sigma[4]), rho*sqrt(Sigma[1])*sqrt(Sigma[4]), Sigma[4]), 2), alpha = .05, npoints = 250, newplot = F, draw = F)
        t.ellipse = cbind(as.data.frame(t.ellipse[,1]), as.data.frame(t.ellipse[,2]))
        colnames(t.ellipse) = cue_names
        t.prob = z
      }
    }

    d.ellipse$z = 0
    t.ellipse$z = 0

    # create categorization surface
    resp.prob = d.prob/(d.prob + t.prob)
    resp.prob.fixed <- resp.prob

    # fix the quadratic effects along cue 1 (i.e., VOT)
    resp.prob.fixed <- fix_quadratic_effects(resp.prob, n)

    # fix the quadratic effects along cue 2 (i.e., f0)
    resp.prob.fixed <- fix_quadratic_effects(t(resp.prob.fixed), n)
    resp.prob.fixed = t(resp.prob.fixed)

    # add lapse rate and response bias
    resp.prob.fixed = (1-lambda) * resp.prob.fixed + lambda * pi
    df.resp = list(x,y,resp.prob.fixed)
    names(df.resp) = c(cue_names, "d_prop")

    color <- rep(0, length(df$z))


    output<-list(d.bivn, t.bivn, d.ellipse, t.ellipse, df.resp, color)
    names(output) <- c("d.bivn", "t.bivn", "d.ellipse", "t.ellipse", "df.resp", "color")
    return(output)
}

# Function to make category distributions in 3D space (x-cue1, y-cue2, z-density)
plot_3D.density <- function(d.bivn, t.bivn, d.ellipse, t.ellipse, color){
  # plot category density
  plot_ly(width = p_width, height = p_height) %>%
    add_surface(x = d.bivn$x, y = d.bivn$y, z = d.bivn$z,
                opacity = 0.2,
                name=category.contrasts[1],
                colors = colors.voicing,
                colorscale = list(c(0, 1), c(colors.voicing[1], colors.voicing[1])),
                surfacecolor=color,
                cauto=F,
                cmax=1,
                cmin=0,
                showscale = FALSE) %>%
    add_surface(x = t.bivn$x, y = t.bivn$y, z = t.bivn$z,
                opacity = 0.2,
                name=category.contrasts[2],
                colorscale = list(c(0, 1), c(colors.voicing[2], colors.voicing[2])),
                surfacecolor=color,
                cauto=F,
                cmax=1,
                cmin=0,
                showscale = FALSE) %>%
    add_trace(x = d.ellipse$VOT, y = d.ellipse$f0, z = t(d.ellipse$z),
              type="scatter3d", mode="markers",
              marker = list(size = 10), opacity = 0,
              opacity = 1, color = colors.voicing[1], size = 0.01, showlegend = FALSE) %>% # this layer is just used to create the desired legend marker size
    add_trace(x = d.ellipse$VOT, y = d.ellipse$f0, z = t(d.ellipse$z),
              type="scatter3d", mode="markers",
              marker = list(size = 2),
              opacity = 1, color = colors.voicing[1], size = 0.01, name=category.contrasts[1]) %>%
    add_trace(x = t.ellipse$VOT, y = t.ellipse$f0, z = t(t.ellipse$z),
              type="scatter3d", mode="markers",
              marker = list(size = 2),
              opacity = 1, color = colors.voicing[2], size = 0.01, name=category.contrasts[2]) %>%
    layout(
      legend = list(itemsizing = "constant",
                    font = list(size = 22),
                    orientation = "h",   # show entries horizontally
                    xanchor = "center",  # use center of legend as anchor
                    x = 0.5, y = 0.9), # specify legend position: x, y values between -2 and 3
      scene = list(
        aspectratio = list(x = 1.2, y = 1.2, z = 1), # zooming in on the plot, values larger than 0
        camera = list(eye = list(x = -0.5, y = -2.5, z = 0.5),
                      #   eye = list(x = -1.25, y = -2.5, z = 1), # perspective good for showing density of the two categories
                      up =  list(x = 0, y = 0, z = 1)),
        zaxis = list(title = "Density", titlefont = list(size = 22)),
        yaxis = list(title = "f0 (Mel)", titlefont = list(size = 22)),
        xaxis = list(title = "VOT (ms)", titlefont = list(size = 22))
    ))
}

# Function to make categorization surface in 3D space (x-cue1, y-cue2, z-prop of category1)
plot_3D.categorization <- function(df.resp){
  # plot categorization surface
  p.3d.categorization <- plot_ly(width = p_width, height = p_height) %>%
    add_surface(x = df.resp$VOT, y = df.resp$f0, z = df.resp$d_prop,
                opacity = 0.5,
                # showlegend = FALSE,
                showscale = FALSE,
                colorscale = list(c(0, 1), c(colors.voicing[2], colors.voicing[1])),
                cmin = 0,
                cmid = 0.5,
                cmax = 1
    ) %>%
    colorbar(title = paste0('Posterior probability\nof ', category.contrasts[1]),
             len = .75,titlefont = list(size = 22),
             x = 0.9, y = 0.9) %>%
    layout(
      scene = list(
        aspectratio = list(x = 1.2, y = 1.2, z = 1), # zooming in on the plot, values larger than 0
        camera = list(
          #eye = list(x = -1.25, y = -2.5, z = 1),
          eye = list(x = -0.5, y = -2.5, z = 0.5), # perspective good for showing categorization curve
          up =  list(x = 0, y = 0, z = 1)),
        #   zaxis = list(range = VO, autotick = F, tickmode = "array", tickvals = c(0.15,0.10,0.05)),
        zaxis = list(title = "Posterior probability of /d/", titlefont = list(size = 22), range = c(0,1), tickvals = c(0,0.2,0.4,0.6,0.8,1)),
        yaxis = list(title = "f0 (Mel)",titlefont = list(size = 22)),
        xaxis = list(title = "VOT (ms)", titlefont = list(size = 22))
        )
    )
}

# Function to show differences in categorization surface in 3D log-odds space (x-cue1, y-cue2, z-prop of category1)
plot_3D.categorization.diff <- function(df.resp){
  # plot categorization surface
  p.3d.categorization <- plot_ly(width = p_width, height = p_height) %>%
    add_surface(x = df.resp$VOT, y = df.resp$f0, z = df.resp$d_diff,
                opacity = 0.5,
                # showlegend = FALSE,
                showscale = FALSE,
                colorscale = list(c(0, 0.5, 1), c("red", "lightgrey","blue")),
                cmin = -15,
                cmid = 0,
                cmax = 15
    ) %>%
    colorbar(title = paste0('Posterior probability\nof ', category.contrasts[1]),
             len = .75,titlefont = list(size = 22),
             x = 0.9, y = 0.9) %>%
    layout(
      scene = list(
        aspectratio = list(x = 1.2, y = 1.2, z = 1), # zooming in on the plot, values larger than 0
        camera = list(
          #eye = list(x = -1.25, y = -2.5, z = 1),
          eye = list(x = -0.5, y = -2.5, z = 0.5), # perspective good for showing categorization curve
          up =  list(x = 0, y = 0, z = 1)),
        #   zaxis = list(range = VO, autotick = F, tickmode = "array", tickvals = c(0.15,0.10,0.05)),
        zaxis = list(title = "Diff. in posterior<br>log-odds of /d/", titlefont = list(size = 22), range = c(-5,15)),
        yaxis = list(title = "f0 (Mel)",titlefont = list(size = 22)),
        xaxis = list(title = "VOT (ms)", titlefont = list(size = 22))
      )
    )
}

# Function to make categorization surface in 3D space based on the modeling results from the three change mechanisms
prepare_3D.categorization_from_results <- function(data, cue1_range, cue2_range, n){
  
  x<-seq(cue1_range[1], cue1_range[2],length=n)  # generating the vector series cue 1
  y<-seq(cue2_range[1], cue2_range[2],length=n) 

  
  d.input = expand.grid(x, y)
  colnames(d.input) = c("VOT", "f0")
  temp2 = as.data.frame(d.input) %>%
    mutate(x = map2(VOT, f0, ~ c(.x, .y)))
 
  
  output = vector(mode = "list", length = length(conditions.AA))
  for (i in 1:length(conditions.AA)){

    ##----------------
    #convert cue values based on the mu_inferred for the current parameter of prior_kappa.normalization

    if(data$model == "Normalization"){
      d.AA.normalization.step0 <- d.AA.exposure %>%
        add_prior_and_normalize_test_tokens_based_on_exposure.AA(data.test = d.AA.test, prior.normalization = prior_marginal_VOT_f0_stats, prior.categories = m.ia.VOT_f0.AA) %>%
        filter(prior_kappa.normalization %in% levels(factor(d.AA3$prior_kappa.normalization))) %>%
        filter(Condition == conditions.AA[i]) %>%
        droplevels()

      temp2 %<>%
        mutate(mu_inferred = d.AA.normalization.step0$mu_inferred[1],
               x = map2(x, mu_inferred, ~ .x - (.y - prior_marginal_VOT_f0_stats$x_mean[[1]])))
    }
    ##----------------

    d.output <- data %>%
      crossing(temp2 %>% distinct(x)) %>%
      nest(x = c(x)) %>%
      add_categorization() %>%
      filter(Condition == conditions.AA[i] & category == "/d/") %>%
      group_by(Condition) %>%
      unnest(x) %>%
      mutate(nrow = row_number(),
             cue_name = ifelse((nrow %% 2) == 0, "f0", "VOT")) %>%
      select(-nrow) %>%
      pivot_wider(values_from = x, names_from = cue_name)

      df.resp = list()
      df.resp$x = x
      df.resp$y = y


    df.resp$d_prop = t(matrix(d.output$response, ncol=n))

    output[[i]] = df.resp
  }
  return(output)
}
